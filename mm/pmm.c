#include <x86.h>
#include <error.h>
#include <types.h>
#include <stdio.h>
#include <string.h>
#include <rtc.h>
#include <mmu.h>
#include <memlayout.h>
#include <pmm.h>

size_t npages;			// Amount of physical memory (in pages)
static size_t npages_basemem;	// Amount of base memory (in pages)

// These variables are set in mem_init()
pde_t *kern_pgdir;		// Kernel's initial page directory
struct Page *pages;		// Physical page state array
static struct Page *page_free_list;	// Free list of physical pages

static void check_page_alloc();
static void check_pgdir();
static void check_kern_pgdir();

// --------------------------------------------------------------
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static void i386_detect_memory(void)
{
	size_t basemem, extmem, ext16mem, totalmem;

	// Use CMOS calls to measure available base & extended memory.
	// (CMOS calls return results in kilobytes.)
	basemem = nvram_read(NVRAM_BASELO);
	extmem = nvram_read(NVRAM_EXTLO);
	ext16mem = nvram_read(NVRAM_EXT16LO) * 64;

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (ext16mem)
		totalmem = 16 * 1024 + ext16mem;
	else if (extmem)
		totalmem = 1 * 1024 + extmem;
	else
		totalmem = basemem;

	if (totalmem*1024 > KMEMSIZE)
		totalmem = KMEMSIZE/1024;

	npages = totalmem / (PGSIZE / 1024);
	npages_basemem = basemem / (PGSIZE / 1024);

	cprintf("Physical memory: %uK available, base = %uK, extended = %uK, npages = %d, npages_basemem = %d\n",
		totalmem, basemem, totalmem - basemem, npages, npages_basemem);
}

// This simple physical memory allocator is used only while JOS is setting
// up its virtual memory system.  page_alloc() is the real allocator.
//
// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
//
// If n==0, returns the address of the next free page without allocating
// anything.
//
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void * boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// Lab2-1,your code here

	return result;
}

// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------
//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
static void page_init()
{
  // Lab2-1,your code here
  // get virtual address(va) of each page,
  // if va < nextfree,then can't use this page,set pp_ref=1
  // if va >= nextfree,put this page on page_free_list,set pp_ref=0

}

struct Page* alloc_page()
{
	struct Page *result = page_free_list;

	if (page_free_list < pages || &pages[npages] < page_free_list) {
		return NULL;
	}

	page_free_list = page_free_list->pp_link;
	result->pp_link = NULL;
	return result;
}

void free_page(struct Page *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0)
		panic("page_free: pp->pp_ref is nonzero\n");
	if (pp->pp_link != NULL)
		panic("page_free: pp->pp_link is not NULL\n");

	pp->pp_link = page_free_list;
	page_free_list = pp;
}

//get_pte - get page table addr of va.
pte_t * get_pte(pde_t *pgdir, uintptr_t va, bool create)
{
    // Lab2-1,your code here
    // use pgdir,PDX,PTE_P,alloc_page(),page2pa(),memset,KADDR,pa | PTE_U | PTE_W | PTE_P,KADDR,PDE_ADDR,PTX
    return 0;
}

//get_page - get related Page struct for linear address la using PDT pgdir
struct Page *get_pte_page(pde_t *pgdir, uintptr_t va, pte_t **ptep_store)
{
    pte_t *ptep = get_pte(pgdir, va, 0);
    if (ptep_store != NULL) {
        *ptep_store = ptep;
    }
    if (ptep != NULL && (*ptep & PTE_P)) {
        return pte2page(*ptep);
    }
    return NULL;
}

//page_remove_pte - free an Page sturct which is related virtual address va
//                - and clean(invalidate) pte which is related virtual address va
//note: PT is changed, so the TLB need to be invalidate
static void page_remove_pte(pde_t *pgdir, uintptr_t va, pte_t *ptep)
{
    // Lab2-1,your code here
    // use PTE_P,pte2page,page_ref_dec,free_page,tlb_invalidate()

}

//page_remove - free an Page which is related virtual address va and has an validated pte
void
page_remove(pde_t *pgdir, uintptr_t va)
{
    pte_t *ptep = get_pte(pgdir, va, 0);
    if (ptep != NULL) {
        page_remove_pte(pgdir, va, ptep);
    }
}

//page_insert - build the map of phy addr of an Page with the addr va
// paramemters:
//  pgdir: the kernel virtual base address of PDT
//  page:  the Page which need to map
//  va:    the virtual address need to map
//  perm:  the permission of this Page which is setted in related pte
// return value: always 0
//note: PT is changed, so the TLB need to be invalidate
int page_insert(pde_t *pgdir, struct Page *page, uintptr_t va, uint32_t perm)
{
    pte_t *ptep = get_pte(pgdir, va, 1);
    if (ptep == NULL) {
        return -E_NO_MEM;
    }
    page_ref_inc(page);
    if (*ptep & PTE_P) {
        struct Page *p = pte2page(*ptep);
        if (p == page) {
            page_ref_dec(page);
        } else {
            page_remove_pte(pgdir, va, ptep);
        }
    }
    *ptep = page2pa(page) | PTE_P | perm;
    tlb_invalidate(pgdir, va);
    return 0;
}

// invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
void tlb_invalidate(pde_t *pgdir, uintptr_t va)
{
    if (rcr3() == PADDR(pgdir)) {
        invlpg((void *)va);
    }
}

// Map [va, va+size) of virtual address space to physical [pa, pa+size)
// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
// va and pa are both page-aligned.
// Use permission bits perm|PTE_P for the entries.
//
// This function is only intended to set up the ``static'' mappings
// above UTOP. As such, it should *not* change the pp_ref field on the
// mapped pages.
//
static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, uintptr_t pa, uint32_t perm)
{
    assert(PGOFF(va) == PGOFF(pa));
    int n = ROUNDUP(size + PGOFF(va), PGSIZE) / PGSIZE;
    va = ROUNDDOWN(va, PGSIZE);
    pa = ROUNDDOWN(pa, PGSIZE);
    // Lab2-1,your code here
    // get_pte of each va,set pa and PTE_P|perm to pte

}

void pmm_init()
{
	uint32_t cr0;
	i386_detect_memory();

	//panic("");

	// create initial page directory.
	kern_pgdir = (pde_t *)boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	pages = (struct Page *)boot_alloc(npages * sizeof(struct Page));
	memset(pages, 0, npages * sizeof(struct Page));

	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();
	check_page_alloc();

	check_pgdir();

    // map all physical memory to linear memory with base linear addr KERNBASE
    //linear_addr KERNBASE~KERNBASE+KMEMSIZE = phy_addr 0~KMEMSIZE
    //But shouldn't use this map until enable_paging() & gdt_init() finished.
    boot_map_region(kern_pgdir, KERNBASE, npages*4096, 0, PTE_W);

	// Switch from the minimal entry page directory to the full kern_pgdir
	// page table we just created.	Our instruction pointer should be
	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
	// mapped the same way by both page tables.
	//
	// If the machine reboots at this point, you've probably set up your
	// kern_pgdir wrong.
	lcr3(PADDR(kern_pgdir));
	// entry.S set the really important flags in cr0 (including enabling
	// paging).  Here we configure the rest of the flags that we care about.
	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);

    check_kern_pgdir();
}


// --------------------------------------------------------------
// Checking functions.
// --------------------------------------------------------------

//
// Check that the pages on the page_free_list are reasonable.
//
static void check_page_alloc()
{
	struct Page *pp, *pp0, *pp1, *pp2;
	int nfree;
	struct Page *fl;
	char *c;
	int i;

	if (!pages)
		panic("'pages' is a null pointer!");

	// check number of free pages
	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
		++nfree;

	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
	assert((pp0 = alloc_page()));
	assert((pp1 = alloc_page()));
	assert((pp2 = alloc_page()));

	assert(pp0);
	assert(pp1 && pp1 != pp0);
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
	assert(page2pa(pp0) < npages*PGSIZE);
	assert(page2pa(pp1) < npages*PGSIZE);
	assert(page2pa(pp2) < npages*PGSIZE);

	// temporarily steal the rest of the free pages
	fl = page_free_list;
	page_free_list = 0;

	// should be no free memory
	assert(!alloc_page());

	// free and re-allocate?
	free_page(pp0);
	free_page(pp1);
	free_page(pp2);
	pp0 = pp1 = pp2 = 0;
	assert((pp0 = alloc_page()));
	assert((pp1 = alloc_page()));
	assert((pp2 = alloc_page()));
	assert(pp0);
	assert(pp1 && pp1 != pp0);
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
	assert(!alloc_page());

	// test flags
	memset(page2kva(pp0), 1, PGSIZE);
	free_page(pp0);
	assert((pp = alloc_page()));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	memset(c, 0, PGSIZE);
	for (i = 0; i < PGSIZE; i++)
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;

	// free the pages we took
	free_page(pp0);
	free_page(pp1);
	free_page(pp2);

	// number of free pages should be the same
	for (pp = page_free_list; pp; pp = pp->pp_link)
		--nfree;
	assert(nfree == 0);

	cprintf("check_page_alloc() succeeded!\n");
}

static void check_pgdir()
{
	int nfree;
	struct Page *pp;
    assert(npages <= KMEMSIZE / PGSIZE);
    assert(kern_pgdir != NULL && (uint32_t)PGOFF(kern_pgdir) == 0);
    assert(get_pte_page(kern_pgdir, 0x0, NULL) == NULL);

	// check number of free pages
	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
		++nfree;

    struct Page *p1, *p2;
    p1 = alloc_page();
    assert(page_insert(kern_pgdir, p1, 0x0, 0) == 0);

    pte_t *ptep;
    assert((ptep = get_pte(kern_pgdir, 0x0, 0)) != NULL);
    assert(pte2page(*ptep) == p1);
    assert(page_ref(p1) == 1);

    ptep = &((pte_t *)KADDR(PDE_ADDR(kern_pgdir[0])))[1];
    assert(get_pte(kern_pgdir, PGSIZE, 0) == ptep);

    p2 = alloc_page();
    assert(page_insert(kern_pgdir, p2, PGSIZE, PTE_U | PTE_W) == 0);
    assert((ptep = get_pte(kern_pgdir, PGSIZE, 0)) != NULL);
    assert(*ptep & PTE_U);
    assert(*ptep & PTE_W);
    assert(kern_pgdir[0] & PTE_U);
    assert(page_ref(p2) == 1);

    assert(page_insert(kern_pgdir, p1, PGSIZE, 0) == 0);
    assert(page_ref(p1) == 2);
    assert(page_ref(p2) == 0);
    assert((ptep = get_pte(kern_pgdir, PGSIZE, 0)) != NULL);
    assert(pte2page(*ptep) == p1);
    assert((*ptep & PTE_U) == 0);

    page_remove(kern_pgdir, 0x0);
    assert(page_ref(p1) == 1);
    assert(page_ref(p2) == 0);

    page_remove(kern_pgdir, PGSIZE);
    assert(page_ref(p1) == 0);
    assert(page_ref(p2) == 0);

    //assert(page_ref(pde2page(kern_pgdir[0])) == 1);
    free_page(pde2page(kern_pgdir[0]));
    kern_pgdir[0] = 0;

	// number of free pages should be the same
	for (pp = page_free_list; pp; pp = pp->pp_link)
		--nfree;
	assert(nfree == 0);

    cprintf("check_pgdir() succeeded!\n");
}

static void check_kern_pgdir()
{
	int nfree;
	struct Page *pp;
    pte_t *ptep;
    int i;

	// check number of free pages
	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
		++nfree;

    for (i = 0; i < npages*PGSIZE; i += PGSIZE) {
        assert((ptep = get_pte(kern_pgdir, (uintptr_t)KADDR(i), 0)) != NULL);
        assert(PTE_ADDR(*ptep) == i);
    }

    assert(kern_pgdir[0] == 0);

    struct Page *p;
    p = alloc_page();
    assert(page_insert(kern_pgdir, p, 0x100, PTE_W) == 0);
    assert(page_ref(p) == 1);
    assert(page_insert(kern_pgdir, p, 0x100 + PGSIZE, PTE_W) == 0);
    assert(page_ref(p) == 2);

    const char *str = "Hello world!!";
    strcpy((void *)0x100, str);
    assert(strcmp((void *)0x100, (void *)(0x100 + PGSIZE)) == 0);

    *(char *)(page2kva(p) + 0x100) = '\0';
    assert(strlen((const char *)0x100) == 0);

    page_remove(kern_pgdir, 0x100);
    assert(page_ref(p) == 1);

    page_remove(kern_pgdir, 0x100 + PGSIZE);
    assert(page_ref(p) == 0);

    free_page(pde2page(kern_pgdir[0]));
    kern_pgdir[0] = 0;

	// number of free pages should be the same
	for (pp = page_free_list; pp; pp = pp->pp_link)
		--nfree;
	assert(nfree == 0);

    cprintf("check_kern_pgdir() succeeded!\n");
}

